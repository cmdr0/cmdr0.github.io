# Spectrum EU2251

Picked this bad boy up for $24.25 with shipping on eBay

![](img/s-l1600.jpg)

Let's break it open

- [Initial Investigation](#initial-investigation)
- [Dumping the Firmware](#dumping-the-firmware)
- [Execution](#execution)
- [Shell](#shell)
- [Interrogating Services](#interrogating-services)
	- [lighttpd](#lighttpd)

## Initial Investigation

`nmap` showed ports 80 and 443 as filtered, but otherwise provided no information when plugged in LAN-side

Pulling it open and probing around with PulseView, I pretty quickly found UART.  This picture was taken further into the process, so it also shows that while I didn't know it at the time, and while this device didn't have USB support out-of-the-box, there were working traces for USB.  Additionally, there were two sets of 5-pin headers very near the CPU/RAM that I haven't yet identified the use for.  I soldered pins to all of them for testing.

![](img/headers.jpg)

The flash chip is on the back (more on this later!), and other than that, we see a lot of remarks about "BCM3390" (understood to be the processor in use here)

Interestingly, while there's an FCC stamp, the FCC ID isn't listed on the device anywhere I can see.  Confirmed that the original manufacturer is Ubee on Spectrum's website

![](img/ubee-confirmation.png)

Also found a [datasheet](resources/SpectrumD31EMTA_New_Sheet.pdf)

### UART

Logging UART as I power it on, here are some interesting snippets:

```
[33;1m    ,/   [0m 
[33;1m  ,'/___,[0m BOLT v4.01 v4.01_B1 LOCAL BUILD
[33;1m.'__  ,' [0m (2019-08-12 09:39:08 ubee@ubee-VirtualBox-nb)
[33;1m   /,'   [0m Copyright (C) 2019 Broadcom Limited
[33;1m  /'     [0m 
[0m
Board: BCM93390VVCM
```

BOLT bootloader, further confirming Ubee manufacture, and Broadcom chipset

Working back from this, we can find what appears to be an FCC filing for... perhaps a precursor to this same device?
- [Internal Photos](resources/fcc-internalphotos.pdf)
- [Charter User Manual](resources/fcc-usermanual.pdf)

Interestingly, the Charter user manual specifies that you can login from the LAN side, and that they login with `technician` and a generated "Password of the Day."  [More info about the Password of the Day, at least for Arris modems](https://arrispwgen.borfast.com/about)

```
Executing STARTUP...
Loader:raw Filesys:raw Dev:flash0.devtree1 File:(null) Options:(null)
Loading: ....
 65536 bytes read
Partition flash0.devtree1 size 262144
Searching for matching DTB
Found matching DTB rg.3390v0-vvcm.dtb
Loading DTB rg.3390v0-vvcm.dtb
Loader:zimg Filesys:raw Dev:flash0.kernel1 File:(null) Options:ubi.mtd=flash0.rg1 ubi.block=0,rootfs rootfstype=squashfs root=/dev/ubiblock0_0 ro platformboot ubifs_data coherent_pool=1M 
Reading 3400008 bytes from zImage...........
No OPPs generated by bolt
Starting program at 0x8000 (DTB @ 0x7627000)
```

```
[    0.000000] Linux version 4.9.248-Prod_21.2 (ubee@ubee-B560M-AORUS-ELITE) (gcc version 6.3.0 (crosstool-NG ) ) #9 SMP Thu Aug 25 11:21:18 CST 2022
```

```
[    1.432840] bcm7038-wdt f040a200.watchdog: Registered BCM7038 Watchdog
[    1.439760] bcm3390-wdt f040a100.watchdog: Registered bcm3390 watchdog
```

The [BCM7038](resources/BCM7038.PDF) is a video-related chip; it might not be present

```
starting pid 1404, tty '': '/etc/init.d/rcS'
Mounting virtual filesystems
==============================
CHIP:3390
MANUFACT_BITS: 5CC7
BOARD ID: 000000D0
SUBSYSTEM: rg
VFLASH: n
EXTENSION: 
KERNEL: vmlinuz-3390b0
STARTUP: BA=y RC=y AUTO=y
LATTICE: y
==============================
```

```
Mounting flash0.rgnonvol0 (mtd 10) to /data
```

Eventually, we're dropped to a normal Linux login prompt.

## Dumping the Firmware

Let's see if we can get access before Linux loads.  After I see the lightning bolt in the UART terminal...

![](img/short.jpg)

I ground an IO pin on the flash chip, causing a communication error, and sure enough:

```
NAND: uncorrectable read error at 0x1600000

Could not load (null): Bad executable format
DT: error FDT_ERR_BADMAGIC
BOLT>
```

Bootloader shell.

I investigated a lot of potential options to get the firmware off the device, but ultimately ended up doing it the caveman way - I loaded the filesystem into memory, and then I scripted out using the bootloader's memory inspect feature to dump it in hexdump format over the serial connection:

```python
import serial

def read_until(ser, bstring):
    print(ser.read_until(bstring).decode())

def main(devpath):
    with serial.Serial(devpath, 115200) as ser:
        ser.write(b'\n')
        read_until(ser, b'BOLT>')

        for start_addr in [hex(x) for x in range(0x0a160000, 0x0ffc0000, 0x100000)]:
            ser.write(f'd -b {start_addr} 0x100000\n'.encode())
            chunk = ser.read_until(b'BOLT>')
            print(f'Writing outfile... {start_addr}')
            with open(f'dump-{start_addr}', 'wb') as outfile:
                outfile.write(chunk)

if __name__ == '__main__':
    # TODO: argparse
    main('/dev/ttyUSB0')
```

This took over 12 hours to complete for ~95MB, but with a little bit of `cat` and a little bit more `xxd -r`, I had a filesystem!

Despite my OS understanding that it was a UBI filesystem, it didn't know how to mount it, and so eventually I threw it at Emba to unpack, which it did, so now I could investigate the filesystem some.

## Execution

### Just Login

`root:$6$2PtwfEEJ$6wUOnAuSauNnTajWdpc5wYexlT6S.CuuMsZkWyNb4nbjHp1/iFEhDwDV2G/ztVsnfD/MaEzeVSpSyWkgnJBV6/:0:0:root:/root:/bin/sh`

Haven't found a matching password for the hash yet.

### USB Auto Upgrade

Turns out, there's a method to upgrade the device via USB; if `usbauto` is passed on the kernel commandline, there's an init script to mount a USB device and run `autorun.sh` off of it.

`/etc/init.d/rcS.util`:
```bash
	# If "usbauto" is specified on the command line, a USB auto upgrade
	# will be done.
	if $(grep -q usbauto /proc/cmdline)
	then
		USBAUTO=y
	else
		USBAUTO=n
	fi
```

`/etc/init.d/rcS.rg`:
```bash
# USB auto upgrade case
if [ "$USBAUTO" = "y" ]; then
	echo "Detected USB auto boot option"
	if [ -f /root/rc.user ]; then
		echo "Starting user services"
		/bin/sh /root/rc.user
	fi
fi
```

`/root/rc.user`:
```bash
grep usbauto /proc/cmdline > /dev/null
if [ $? -eq 0 ]; then
	#wait for usb stick to be recognized and mount it
	#by definition, update files must be in first partition of USB stick
	#First, try w/ no partition table (i.e. /dev/sda), then try the first
	#partition (i.e. /dev/sda1)
	mount_usb " " ${mountpoint}
	if [ $? -ne 0 ]
	then
		mount_usb 1 ${mountpoint}
		if [ $? -ne 0 ]
		then
			echo FAILED TO MOUNT USB STICK
			exit -1
		fi
	fi
	pushd ${mountpoint} > /dev/null
	./autorun.sh
```

This is actually the point where I realized that the four-pin header that I found was USB.  So in order to get execution, I:
- Wrote a FAT32 flash drive and put my `autorun.sh` script on there
- Soldered a USB-B connector onto the header and plugged my flash drive in
- Rebooted and shorted the flash again to return to the bootloader shell
- Appended `usbauto` to the kernel commandline in the STARTUP command
- Proved execution on the device by printing this in the terminal during bootup:

```
================================================================================
        ____________________________________________________                    
       /                                                    |___________        
      /  #  ##   ####  ####    ###   #  ##  #####   ###     |   __      |       
     (   #  ##  #      #  ##  #  ##  #  ##    ##   #  ##    |  |__|     |       
     |   #  ##   ###   ####   #####  #  ##    ##   #  ##    |           |       
     |   #  ##     ##  #  ##  #  ##  #  ##    ##   #  ##    |   __      |       
     (   #####  #  ##  #  ##  #  ##  #####    ##   #  ##    |  |__|     |       
      \   ###    ###   ####   #  ##   ###     ##    ###     |___________|       
       \____________________________________________________|                   
                                                                                
================================================================================
```

## Shell

### Just Login

I didn't actually try replacing `/etc/passwd` for a couple of reasons:
- I wanted to touch the filesystem as little as possible, I don't want to find out I've missed a secure boot check and have to figure out re-flashing the device
- It may not have worked for a few different reasons (order of operations, read-only filesystems, etc)

So I went searching.  I attempted to spin up `telnetd` from busybox, but for some reason I could never get in (more on that later).  I figured maybe my `iptables` rules were getting squashed further down in the init, so I went looking for more ways in.  I found a much more persistent method further down the init chain:

`/usr/local/etc/rc.apps`
```bash
# start ste script
STE_SCRIPT_PATH_FILE=/data/ste_script
if [ -f $STE_SCRIPT_PATH_FILE ]; then
    STE_SCRIPT=$(cat $STE_SCRIPT_PATH_FILE)
    if [[ ! -z "$STE_SCRIPT" ]]; then
        echo "Executing STE script file: $STE_SCRIPT_PATH_FILE"
        source $STE_SCRIPT_PATH_FILE
    fi
fi
```

So I used USBAUTO to drop a script there that should have spun up `telnetd` and... still nothing.  Weird.  So I kept looking for what could have caused it, when I came across the way in I used for most of my device interrogation:

### Don't Bother Logging In

`/etc/inittab`:
```bash
#_ BAM a shell before we init, because we never want to be caught with
#_ our shell down.
#ttyS0::respawn:/sbin/getty -L 115200 ttyS0 vt102
::respawn:/bin/cttyhack /bin/loginscript.sh

# main rc script
::sysinit:/etc/init.d/rcS

# Stuff to do before rebooting
null::shutdown:/bin/umount -a -r
```

`/bin/loginscript.sh`:
```bash
#!/bin/bash

NOLOGIN=/data/.nologin

if [ -f "$NOLOGIN" ]; then
	/bin/cttyhack /bin/sh -l
else
	/sbin/getty -L 115200 ttyS0 vt102
fi
```

Basically, the shell we're given is decided by `loginscript.sh` - but if `/data/.nologin` exists, it'll just pass us `/bin/sh` over BusyBox's `cttyhack` (which takes care of TTY allocation).  So with USBAUTO adjusted slightly to go ahead and `touch /data/.nologin`, we get the following over UART now when we connect:

```
[3390:RG]# whoami
root
[3390:RG]#
```

### Why telnetd didn't work

The IP address of the device _isn't actually_ 192.168.100.1 (which is where it tells you to reach out to it); it's _actually_ 192.168.**0**.1, and it uses some pre-routing magic to forward ports in.

```
[3390:RG]# iptables -nvL -tnat
Chain PREROUTING (policy ACCEPT 0 packets, 0 bytes)
 pkts bytes target     prot opt in     out     source               destination
    0     0 DNAT       tcp  --  *      *       0.0.0.0/0            192.168.100.1        multiport dports 80,443 to:192.168.0.1
```

So opening all the ports in the world didn't matter, because I didn't know to DNAT the connection in.

## Interrogating Services

Checking `netstat`...

```
[3390:RG]# netstat -anp
netstat: showing only processes with your user ID
Active Internet connections (servers and established)
Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name
tcp        0      0 0.0.0.0:80              0.0.0.0:*               LISTEN      3867/lighttpd
tcp        0      0 172.31.255.40:23        0.0.0.0:*               LISTEN      3913/telnetd
tcp        0      0 0.0.0.0:443             0.0.0.0:*               LISTEN      3867/lighttpd
tcp        0      0 :::80                   :::*                    LISTEN      3867/lighttpd
tcp        0      0 :::443                  :::*                    LISTEN      3867/lighttpd
udp        0      0 172.31.255.20:45821     0.0.0.0:*                           2443/rprogramstore
udp        0      0 0.0.0.0:36906           0.0.0.0:*                           2449/rnonvolhost
udp        0      0 172.31.255.40:69        0.0.0.0:*                           3811/udpsvd
udp        0      0 172.31.255.20:30583     0.0.0.0:*                           2449/rnonvolhost
udp        0      0 172.31.255.20:34952     0.0.0.0:*                           2443/rprogramstore
udp        0      0 127.0.0.1:63391         0.0.0.0:*                           3918/diagmand
udp        0      0 172.31.255.40:63391     0.0.0.0:*                           3918/diagmand
udp        0      0 0.0.0.0:161             0.0.0.0:*                           3905/snmpd
udp        0      0 127.0.0.1:9930          0.0.0.0:*                           4019/powerman
udp        0      0 :::161                  :::*                                3905/snmpd
Active UNIX domain sockets (servers and established)
Proto RefCnt Flags       Type       State         I-Node PID/Program name    Path
unix  2      [ ACC ]     STREAM     LISTENING       3174 2456/mboxassist     /var/ma
unix  2      [ ACC ]     STREAM     LISTENING       5261 3868/php-cgi        /tmp/php.socket-0
unix  2      [ ACC ]     STREAM     LISTENING       3233 2467/bootassist     /var/ba
unix  2      [ ]         DGRAM                      4278 3782/latticerpcd    /var/lattice_rpc_ipc_server_addr
unix  2      [ ]         DGRAM                      5710 3782/latticerpcd
```

... gave me the following list of 'touch points' based on network access vector:

- lighttpd | 0.0.0.0:80,443
  - cmdline: `lighttpd -f/usr/local/etc/lighttpd/lighttpd.conf -m/usr/local/lib/`
  - which: `/usr/local/sbin/lighttpd`
  - Notes: 
    ```
	lighttpd/1.4.55 (ssl) - a light and fast webserver
	usage:
	-f <name>  filename of the config-file
	-m <name>  module directory (default: /lib)
	-i <secs>  graceful shutdown after <secs> of inactivity
	-1         process single (one) request on stdin socket, then exit
	-p         print the parsed config-file in internal form, and exit
	-t         test config-file syntax, then exit
	-tt        test config-file syntax, load and init modules, then exit
	-D         don't go to background (default: go to background)
	-v         show version
	-V         show compile-time features
	-h         show this help
	```
    - This was blocked lan-side by iptables rules
- telnetd | 172.31.255.40:23
  - cmdline: `telnetd -b 172.31.255.40`
  - which: `/sbin/telnetd -> ../bin/busybox`
  - Notes: The 172.31.255.0/24 subnet appears to be used for internal management of the device; I guess under normal use, it _is_ Charter's modem, so I can't say a lot about them deciding to grant themselves unfettered shell access to it over their management network, but just another indication that carrier-supplied modems are untrusted devices and should be treated as such.
- rprogramstore | 172.31.255.20:34952,45821
  - cmdline: `/bin/rprogramstore -i privbr:0 -s 172.31.255.20 -d 172.31.255.45 -c y`
  - which: `/bin/rprogramstore`
  - Notes:
    ```
	/bin/rprogramstore: invalid option -- '-'
	Usage: rprogramstore -i <interface>
	optional: -s <myipaddress>
	optional: -d <destipaddress>
	optional: -c <configure interface y or n>)
	```
- rnonvolhost | 0.0.0.0:36906, 172.31.255.20:30583
  - cmdline: `/bin/rnonvolhost privbr:0 172.31.255.20 172.31.255.45 /mnt/cmnonvol/cm_perm.bin /mnt/cmnonvol/cm_dyn.bin y`
  - which: `/bin/rnonvolhost`
  - Notes: 
    - `Usage: /bin/rnonvolhost interface, myipaddress, destipaddress, permnonvolfile, dynnonvolfile, [config interface (y) or (n)]`
    - It's really weird that this is bound on 0.0.0.0 despite the settings being set for 172.31.255.0/24
- udpsvd | 172.31.255.40:69
  - cmdline: `udpsvd -E 172.31.255.40 69 /sbin/tftpd -c /var/tftpboot`
  - which: `/bin/udpsvd -> busybox`
- diagmand | 127.0.0.1:63391, 172.31.255.40:63391
  - cmdline: `diagmand`
  - which: `/usr/local/bin/diagmand`
- snmpd | 0.0.0.0:161
  - cmdline: `snmpd -c /usr/local/etc/snmp/snmpd.conf`
  - which: `/usr/local/sbin/snmpd`
  - Notes: SNMP seems to be how provisioning is managed
- powerman
  - cmdline: `powerman -v1 -eeth0 eth1 eth2 eth3 eth4 eth7 -s300 -c3390 -u10 -d25`
  - which: `/usr/local/bin/powerman`
  - Notes: 
    ```
	Usage....
	-c <set system chip type (3384 or 3390>
	-n <this is an attempt to communicate with process with various options>
	-x <set external switch mode>
	-e <comma seperated list of ethernet interfaces (eg. eth0,eth1...)>
	-w <comma seperated list of wifi interfaces (eg. wl0,wl1...)>
	-m <comma seperated list of moca interfaces (eg. moca0,moca1...)>
	-s <specified a startup delay before starting powerman activities>
	-d <sleep time in seconds for GHPY to remain powered down for power savings (default = 10secs)>
	-u <sleep time in seconds for GHPY to remain powered up for link detection (default = 5secs)>
	-p <time in seconds to wait between reduced power update checks (default = 5secs)>
	-v debug verbosity level [1,2,3]>
	```

### lighttpd

Version 1.4.55 only has one CVE, CVE-2022-22707, which is a 4-byte buffer overflow when you provide a config file - doesn't seem particularly useful in this case.

Adjusting iptables rules to access the web portal, we're blocked by a login prompt.  Investigating the config to try and find credentials, we find that the login is done using a hard-coded username and a custom "password of the day" module:

```bash
# All pages, except /USDiag, require authetication
$HTTP["url"] !~ "^/USDiag$" {
   ## for plain -- logout does not with plain/htdigest authetication, broswer must be closed for logging out
   #auth.backend = "plain"
   #auth.backend.plain.userfile = "/usr/local/etc/lighttpd/.lighttpd.user.plain"

   ## for htdigest -- logout does not with plain/htdigest authetication, broswer must be closed for logging out
##auth.backend = "htdigest"#UBC1325AA00_SQA-85 foxconn jason 2021/2/5
##auth.backend.htdigest.userfile = "/usr/local/etc/lighttpd/.lighttpd.user.htdigest"#UBC1325AA00_SQA-85 foxconn jason 2021/2/5

   ## for POTD -- with logout mechanism using cookie
auth.backend = "potd"
auth.backend.potd.seed = "z0p0ix406qz4vdqk57kt6uxb4nri87izj750yo21"  ### optional: seed for POTD (seed: ubee)#UBC1325AA00_SQA-85 foxconn jason 2021/2/5

   auth.require = ("/" =>
      (
         # method must be either basic or digest
#UBC1325AA00_SQA-85+ foxconn jason 2021/2/5
#      "method"    => "digest",
      "method"    => "basic",
#UBC1325AA00_SQA-85- foxconn jason 2021/2/5

         # algorithm must MD5, most broswer does not support SHA-256
         "algorithm" => "MD5",   # default value
         #"algorithm" => "SHA-256",   # <-- most broswer does not support this option

         "realm" => "LANRouter",
      #"require" => "valid-user",#UBC1325AA00_SQA-85 foxconn jason 2021/2/5
         # POTD does not check username, requiring this setting for limitting the username
      "require" => "user=technician"   # <--- limit username to 'admin' or 'user'#UBC1325AA00_SQA-85 foxconn jason 2021/2/5
      )
   )
}
```

Investigating further, there's a `/usr/local/lib/mod_authn_potd.so` shared object, which matches one of the modules loaded by the config.  Pulling it back and loading it in Ghidra, we find the following functions handle generating the password:

```C
void potdGetPassword(undefined4 buffer,undefined4 buffer_size,char *seed,uint seedlen)

{
  FILE *__stream;
  char *pcVar1;
  size_t sVar2;
  void *pvVar3;
  char acStack_121 [257];
  
  if (seed == (char *)0x0) {
    seedlen = 0x28;
    seed = "fYoRhuACa0zq7sRdwruqXll2TVR1snWWz7i1w2He";
  }
  else if (0x27 < seedlen) {
    seedlen = 0x28;
  }
  memset(acStack_121 + 1,0,0x100);
  __stream = popen("snmpget -v 2c -c private 172.31.255.45 1.3.6.1.4.1.4684.38.2.2.2.1.1.3.7.0 | cut  -d \':\' -f 2 | sed \'s/\"//g\' | sed \'s/ //g\'"
                   ,"r");
  if ((__stream != (FILE *)0x0) &&
     (pcVar1 = fgets(acStack_121 + 1,0x100,__stream), pcVar1 != (char *)0x0)) {
    sVar2 = strlen(acStack_121 + 1);
    acStack_121[sVar2] = '\0';
  }
  pclose(__stream);
  memcpy(seed,acStack_121 + 1,seedlen);
  pvVar3 = memcpy(pszSeed,seed,seedlen);
  *(undefined *)((int)pvVar3 + seedlen) = 0;
  GetPassword(buffer,buffer_size);
  return;
}
```

```C
undefined4 GetPassword(char *param_1,uint param_2)

{
  tm *ptVar1;
  size_t plaintextLen;
  int tYear;
  int tMonth;
  int tDay;
  time_t tStack_98;
  int b64_outResult;
  undefined4 sha1_outResult;
  undefined sha1buffer [20];
  char plaintext [48];
  char b64buffer [48];
  
  sha1_outResult = 0;
  if (8 < param_2) {
    memset(param_1,0,param_2);
    memset(b64buffer,0,0x30);
    plaintext[0] = '\0';
    time(&tStack_98);
    ptVar1 = gmtime(&tStack_98);
    tYear = tSetTime._20_4_;
    tMonth = tSetTime._16_4_;
    tDay = tSetTime._12_4_;
    if (isTimeMissing == 0) {
      if (isDateSet == 0) {
        if (isDateAdjusted == 0) {
          time(&tStack_98);
          ptVar1 = gmtime(&tStack_98);
          tYear = ptVar1->tm_year;
          tMonth = ptVar1->tm_mon;
          tDay = ptVar1->tm_mday;
        }
        else {
          ptVar1 = gmtime(&tAdjustedTime);
          tYear = ptVar1->tm_year;
          tMonth = ptVar1->tm_mon;
          tDay = ptVar1->tm_mday;
        }
      }
      else {
        ptVar1->tm_year = tSetTime._20_4_;
        ptVar1->tm_mon = tMonth;
        ptVar1->tm_mday = tDay;
      }
    }
    else {
      tMonth = 0;
      tDay = 1;
      tYear = 0x67;
      ptVar1->tm_mon = 0;
      ptVar1->tm_year = 0x67;
      ptVar1->tm_mday = 1;
    }
    sprintf(plaintext,"%d%d%d%s",tYear,tMonth,tDay,pszSeed);
    plaintextLen = strlen(plaintext);
    secCryptoCalcHash(2,plaintext,plaintextLen,"99eo04bb09drw66pp",0x11,sha1buffer,&sha1_outResult);
    secCryptoBase64(sha1buffer,sha1_outResult,b64buffer,&b64_outResult,1,0x50);
    strncpy(param_1,b64buffer,8);
    return 0;
  }
  fwrite("Not enough space for dynamic password\n",1,0x26,stderr);
  return 1;
}
```

```C
undefined4
secCryptoCalcHash(int mode,uchar *plaintext,size_t plaintext_len,void *shared_key,int shared_key_len
                 ,uchar *OUT_buffer,uint *OUT_sz)

{
  EVP_MD *evp_md;
  
  if (shared_key_len != 0 && shared_key != (void *)0x0) {
    if (mode == 2) {
      evp_md = EVP_sha1();
    }
    else {
      if (mode != 1) goto LAB_00011d6c;
      evp_md = EVP_md5();
    }
    HMAC(evp_md,shared_key,shared_key_len,plaintext,plaintext_len,OUT_buffer,OUT_sz);
    return 0;
  }
  if (mode == 2) {
    SHA1(plaintext,plaintext_len,OUT_buffer);
    *OUT_sz = 0x14;
    return 0;
  }
  if (mode == 1) {
    MD5(plaintext,plaintext_len,OUT_buffer);
    *OUT_sz = 0x10;
    return 0;
  }
LAB_00011d6c:
  puts("secLibCalcHash Error: Bad hash type.");
  return 1;
}
```

To paraphrase what these three functions do, they:

- Get the PotD seed in the following priority:
  - Retrieved via SNMP OID 1.3.6.1.4.1.4684.38.2.2.2.1.1.3.7.0
  - Provided from a higher function (in our case, the config, or `z0p0ix406qz4vdqk57kt6uxb4nri87izj750yo21`)
    - The default for these devices could potentially be `ubee`, however
  - Provided as a default, `fYoRhuACa0zq7sRdwruqXll2TVR1snWWz7i1w2He`
- Concatenate the output of `gmtime` with the seed (`sprintf(plaintext, "%d%d%d%s", y, m, d, seed)`)
  - `y` is the current year minus 1900; i.e.:`70` for 1970, `124` for 2024
  - `m` is the index of the current month, 0-indexed; i.e.:`0` for January, `11` for December
  - `d` is the current day of the month, 1-indexed; i.e.: `1` for 1 January, `31` for 31 January
- HMAC-SHA1 the output of that using the hard-coded PSK `99eo04bb09drw66pp`
- Base64 encode the raw bytes (not the hex digest) of that output
- Take the first 8 characters of that to use as the password


# Active Project

Work is ongoing on this project, stay tuned for updates!